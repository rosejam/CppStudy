#include <iostream>
using namespace std;

// Boolean : false(0) or true(1)
bool isPayed = true;

// 사실 bool은 '그냥 1바이트 정수'에 불과! '참/거짓'을 나타내기 위해 사용한다.
// 왜 정수 시간에 안 다뤘을까?
// -> 어셈블리에서 bool이라는 것은 없음
// 무조건 둘 중 하나의 값을 가진다는 걸 알려줌 (가독성)

// 왜 크기가 1비트가 아니고 1바이트나 하지?
// 어셈블리 등에서 최소 단위가 1바이트임 (al, ah 등)

// Floating Point 실수
float healthRegen = -3.375f; // f를 뒤에 안붙이면 double 리터럴이 됨!!!!
double attackSpeed = 123.4123;

// 부동소수점 : .을 유동적으로 움직여서 표현하는 방법
// 3.1415926535
// 1) 정규화 = 0.31415926535 처럼 < 0.유효숫자 * 10^지수 >로 표현하는 방식!!!
// 2) 유효숫자(31415926535)와 지수(1)

// float 부호 1bit, 지수 8bit, 유효숫자 23bit = 32bit = 4byte
// double 부호 1bit, 지수 11bit, 유효숫자 52bit = 64bit = 8byte (더 정밀)

// ex) -3.375f라는 값을 저장
// 1) 2진수 변환 = 3 + 0.375 = 0b11 + 0b0.011 = 0b11.011 
//      0.375 = 0.5*0 + 0.25*1 + 0.125*1 
// 2) 정규화 0b1.1011 * 2^1
// 1(부호) 1(지수) 1011(유효숫자) // (소수점 위 1은 유효숫자에서 제외)
// (단, 지수는 unsigned byte라고 가정하고 +127 해줌) // bias
// 결과 : 0b 1 1000 000'0 1011 000'0 0000 000'0 0000 000 = 0xc0 58 00 00
//      4byte float데이터가 healthRegen에 들어갈 것이다.
//      그 값은 리틀엔디안으로 시작주소부터 0x00 0x00 0x56 0xc0

// !!!! 프로그래밍할 때 부동 소수점은 항상 '근사값'이라는 것을 기억
// 특히 수가 커질 수록 오차 범위도 매우 커짐
// 실수 2개를 ==으로 비교하는 것은 지양하자

int main() 
{
    cout << isPayed << endl; // 1
}
