#include <iostream>
using namespace std;

// 1) 포인터 vs 배열 2탄
// 2) 주의사항 (마음가짐?)

int main()
{
    // 주소를 담는 바구니
    // 진퉁은 저멀리 어딘가에 있음
    // ptr는 단지 그 곳으로 워프하는 포탈
    int *ptr;

    // 진짜배기 원조 데이터
    // 닭장과 같은 데이터의 묶음 (엄청 많고 거대함)
    int arr[10] = { 1,2,3,4,5,6,7,8 };

    // 그런데 상당히 많은 사람들이 [배열 = 포인터]라 착각하는 경향이 있음!

    // - [배열의 이름]은 배열의 시작 주소값을 가리키는 TYPE*형 포인터로 쉽게 변환 가능!!!!
    ptr = arr;
    // -- (배열을 함수 인자로 넘길 때는 자연스럽게 주소를 포인터 타입으로 변환해서 넘긴다!!!!)

    // - [TYPE형 1차원 배열]과 [TYPE*형 포인터]는 완전히 호환이 된다!!
    cout << ptr[0] << endl;
    cout << arr[0] << endl;
    cout << ptr[5] << endl;
    cout << arr[5] << endl;
    cout << *ptr << endl; // ptr[0]과 동일
    cout << *arr << endl;
    cout << *(ptr + 3) << endl; // ptr[3]과 동일
    cout << *(arr + 3) << endl;
    cout << endl;
    // -- (C++ 문법 상 똑같이 사용 가능)

    
    // 지옥을 보여드리겠습니다. (2차원 배열 vs 다중 포인터)
    // arr2[1][2][3][4]
    int arr2[2][2] = { {1, 2}, {3, 4} };
    
    // (int**) pp[ &arr2 ] -----> (int*) 주소1[ 0x200000001(주소2???라고 주장) ] -----> (int) 0x200000001[ ??? ](4바이트 정수의 바구니)
    int** pp = (int**)arr2; // 강제로 캐스팅(형변환)해서 넣어보면
    // cout << **pp << endl; // 메모리 액세스(접근) 예외 발생!
    // 다차원 배열과 다중포인터는 호환되지 않는다!
    // (C++에서 다중포인터는 포인터의 포인터가 맞지만 다차원 배열은 배열의 배열이 아니기 때문)

    // (int*) p[ 주소 ] -----> (int) 주소[1][2][3][4] (4바이트 정수의 바구니)
    int* p = (int*)arr2;
    cout << *p << endl; // 1
    cout << endl;

    // arr2는 int(*)[2] 타입!!!!!
    // int(*)[2] 는 int[2] 배열을 가리키는 포인터 타입!!!! (사실상 "int[2] *"의 의미. 오른쪽부터 대신 괄호 안부터 분석하기!)
    // (int(*)[]) p2[ 주소 ] -----> (int[]) 주소[1][2] [3][4]
    // (int(*)[]) p2[ &arr ] -----> (int[])  arr[1][2] [3][4]
    int(*p2)[2] = arr2;
    cout << (*p2)[0] << endl;
    cout << (*p2)[1] << endl;
    cout << p2[0][0] << endl;
    cout << p2[0][1] << endl;
    // 포인터 산술 연산으로 p2에 +1하면 +sizeof(int[2])가 된다!!
    // 따라서 p2+1은 +8이 되어 다음 int[2]인 [3][4]를 가리키게 된다!!
    cout << (*(p2 + 1))[0] << endl;
    cout << (*(p2 + 1))[1] << endl;
    cout << p2[1][0] << endl;
    cout << p2[1][1] << endl;

    return 0;
}