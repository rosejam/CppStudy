#include <iostream>
using namespace std;

// 1) 포인터 vs 배열 2탄
// 2) 주의사항 (마음가짐?)

int main()
{
    // 주소를 담는 바구니
    // 진퉁은 저멀리 어딘가에 있음
    // ptr는 단지 그 곳으로 워프하는 포탈
    int *ptr;

    // 진짜배기 원조 데이터
    // 닭장과 같은 데이터의 묶음 (엄청 많고 거대함)
    int arr[10] = { 1,2,3,4,5,6,7,8 };

    // 그런데 상당히 많은 사람들이 [배열 = 포인터]라 착각하는 경향이 있음!

    // - [배열의 이름]은 배열의 시작 주소값을 가리키는 [TYPE*형 포인터]로 쉽게 변환 가능!!!
    ptr = arr;
    // -- (배열을 함수 인자로 넘길 때는 자연스럽게 포인터로 변환하여 받는다)

    // - [TYPE형 1차원 배열]과 [TYPE*형 포인터]는 완전히 호환이 된다!!
    cout << ptr[0] << endl;
    cout << arr[0] << endl;
    cout << ptr[5] << endl;
    cout << arr[5] << endl;
    cout << *ptr << endl;
    cout << *arr << endl;
    cout << *(ptr+3) << endl;
    cout << *(arr+3) << endl;
    // -- (C++ 문법 상 똑같이 사용 가능)
    cout << endl;

    
    // 지옥을 보여드리겠습니다. (2차원 배열 vs 다중 포인터)
    // arr2[1][2][3][4]
    int arr2[2][2] = { {1, 2}, {3, 4} };
    
    // (int**) pp[ 주소1 ] -----> (int*) 주소1[ 0x00000001 ] -----> (int) 0x00000001[ ? ](4바이트 정수의 바구니)
    // int** pp = (int**)arr2; // 강제로 넣어보면 메모리 접근 에러 발생
    // cout << (**pp) << endl;                                                             
    // 다차원 배열과 다중포인터는 호환되지 않는다. 
    // (C++에서 다중포인터는 포인터의 포인터가 맞지만 다차원 배열은 배열의 배열이 아니기 때문)

    // (int*) pp[ 주소 ] -----> (int) 주소[1][2][3][4]
    int* pp = arr2;

    // TYPE [개수]
    int(*)[2] 

    return 0;
}