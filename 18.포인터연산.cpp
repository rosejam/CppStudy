#include <iostream>
using namespace std;

// 1) 주소 연산자 (&)
// 2) 산술 연산자 (+ -)
// 3) 간접 연산자 (*)
// 4) 간접 멤버 연산자 (->)

struct Player
{
    int hp; // +0 (구조체 시작주소를 기준으로, 요소의 시작주소의 위치 (=오프셋)!!!)
    int damage; // +4
};

int main()
{
    int number = 1;

    // 1) 주소 연산자 (&)
    // - 해당 변수의 주소를 알려주세요
    // - 거기에, 해당 변수 TYPE에 따라서 포인터형 TYPE*을 반환!!!
    int* pointer = &number;

    // 2*) 산술 연산자 (+ -)
    number += 1;

    // int*
    // 주소를 따라가면 int(4바이트 정수형 바구니)가 있다고 가정
    pointer += 2; // 8 증가했다?!!!! -> int의 크기인 4바이트 단위로 주소를 이동한다!
    
    // [!] 포인터에서 +나 -등 산술 연산을 하면
    // 정말 '그 숫자'를 더하고 빼라는 의미가 아니다.
    // 한번에 TYPE의 크기 단위(바구니 단위)만큼 이동하라!!!!
    // 즉, 1을 더하면 바구니 1개만큼 이동

    // 왜 이런 짓을 ? 배열을 다룰 때 첫번째 데이터 기준으로 포인터를 산술 연산하는 것이 유용함

    // 3) 간접 연산자 (*)
    // - 포탈을 타고 해당 주소로 슝 이동
    *pointer = 3;

    // - 기본 타입 말고, 자체 정의한 타입인 구조체에서의 포인터 사용!
    Player player1;
    player1.hp = 100; // player1 +0 에 있는 int바구니에 200을 넣음
    player1.damage = 10; // player1 +4 에 있는 int바구니에 20을 넣음

    Player* playerPtr = &player1;
    (*playerPtr).hp  = 200; // "playerPtr이 가리키는 주소로 이동 후" +0 에 있는 int바구니에 200을 넣음
    (*playerPtr).damage = 20; // "playerPtr이 가리키는 주소로 이동 후" +4 에 있는 int바구니에 20을 넣음

    // 4) 간접 멤버 연산자 (->)
    // * : 간접 연산자 (포탈타고 해당 주소로 이동)
    // . : 구조체의 특정 멤버를 다룰 때 사용!! (어셈블리 언어로 까보면 .는 사실상 그냥 오프셋 덧셈!!!!)
    // ->는 *와 .을 한방에!
    playerPtr->hp = 200; // 위와 완전히 동일한 표현!!!
    playerPtr->damage = 20;

    return 0;
}